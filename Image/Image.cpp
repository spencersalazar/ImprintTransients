//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

#include <CoreFoundation/CoreFoundation.h>
#include <CoreGraphics/CoreGraphics.h>

// general includes
#include <stdio.h>
#include <limits.h>


t_CKINT image_data_offset = 0;

struct Image
{
    Image() : pixels(NULL), width(0), height(0) { }
    UInt32 *pixels;
    UInt32 width, height;
};


CK_DLL_CTOR(image_ctor)
{
    OBJ_MEMBER_INT(SELF, image_data_offset) = 0;
    
    Image * img = new Image();
    
    OBJ_MEMBER_INT(SELF, image_data_offset) = (t_CKINT) img;
}


CK_DLL_DTOR(image_dtor)
{
    Image * img = (Image *) OBJ_MEMBER_INT(SELF, image_data_offset);
    if( img )
    {
        delete img;
        OBJ_MEMBER_INT(SELF, image_data_offset) = 0;
        img = NULL;
    }
}

bool has_extension(const std::string &filepath, const std::string &ext)
{
    return filepath.compare(filepath.size()-ext.size(), ext.size(), ext) == 0;
}

CK_DLL_MFUN(image_load)
{
    Image * img = (Image *) OBJ_MEMBER_INT(SELF, image_data_offset);
    
    Chuck_String * str = GET_NEXT_STRING(ARGS);
    std::string &filepath = str->str;
    
    CGImageRef spriteImage = NULL;
    CGContextRef spriteContext = NULL;
    CGDataProviderRef dataProvider = NULL;
    size_t width, height;
    
    bool jpeg = false, png = false;
    
    if(has_extension(filepath, ".png")) png = true;
    else if(has_extension(filepath, ".jpeg")) jpeg = true;
    else if(has_extension(filepath, ".jpg")) jpeg = true;
    
    dataProvider = CGDataProviderCreateWithFilename(filepath.c_str());
    
    // Creates a Core Graphics image from an image file
    if(dataProvider)
    {
        if(png)
            spriteImage = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
        else if(jpeg)
            spriteImage = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
    }
    
    if(spriteImage)
    {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        // Get the width and height of the image
        width = CGImageGetWidth(spriteImage);
        height = CGImageGetHeight(spriteImage);
        // Allocated memory needed for the bitmap context
        img->pixels = (UInt32*) calloc(width * height, sizeof(UInt32));
        // Uses the bitmap creation function provided by the Core Graphics framework. 
        spriteContext = CGBitmapContextCreate(img->pixels, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedLast);
        //CGContextTranslateCTM(spriteContext, width/2, height/2);
        //CGContextRotateCTM(spriteContext, M_PI);
        //CGContextTranslateCTM(spriteContext, -width/2, -height/2);
        // After you create the context, you can draw the sprite image to the context.
        CGContextDrawImage(spriteContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), spriteImage);
        // You don't need the context at this point, so you need to release it to avoid memory leaks.
        CGContextRelease(spriteContext);
        
        img->width = width;
        img->height = height;
        
        CGImageRelease(spriteImage); spriteImage = NULL;
        CGColorSpaceRelease(colorSpace); colorSpace = NULL;
    }
    
    if(dataProvider != NULL) { CGDataProviderRelease(dataProvider); dataProvider = NULL; }
    
    RETURN->v_int = spriteImage ? 1 : 0;
}


CK_DLL_MFUN(image_width)
{
    Image * img = (Image *) OBJ_MEMBER_INT(SELF, image_data_offset);
    RETURN->v_int = img->width;
}

CK_DLL_MFUN(image_height)
{
    Image * img = (Image *) OBJ_MEMBER_INT(SELF, image_data_offset);
    RETURN->v_int = img->height;
}

CK_DLL_MFUN(image_pixel)
{
    Image * img = (Image *) OBJ_MEMBER_INT(SELF, image_data_offset);
    
    t_CKINT x = GET_NEXT_INT(ARGS);
    t_CKINT y = GET_NEXT_INT(ARGS);
    
    if(img->pixels && x >= 0 && x < img->width && y >= 0 && y < img->height)
        RETURN->v_int = img->pixels[y*img->width+x];
    else
        RETURN->v_int = 0;
}

CK_DLL_QUERY( Image )
{
    QUERY->setname(QUERY, "Image");
    
    QUERY->begin_class(QUERY, "Image", "Object");

    QUERY->add_ctor(QUERY, image_ctor);
    QUERY->add_dtor(QUERY, image_dtor);
    
    QUERY->add_mfun(QUERY, image_load, "int", "load");
    QUERY->add_arg(QUERY, "string", "arg");
    
    QUERY->add_mfun(QUERY, image_width, "int", "width");
    
    QUERY->add_mfun(QUERY, image_height, "int", "height");

    QUERY->add_mfun(QUERY, image_pixel, "int", "pixel");
    QUERY->add_arg(QUERY, "int", "x");
    QUERY->add_arg(QUERY, "int", "y");
    
    image_data_offset = QUERY->add_mvar(QUERY, "int", "@img_data", false);

    QUERY->end_class(QUERY);

    return TRUE;
}


